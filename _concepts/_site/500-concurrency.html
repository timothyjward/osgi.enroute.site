<p>In OSGi you will write code that runs in a multi-threaded environment. There are
no safe guards, no hand-rails, and no warning signs. When you register a service
anybody can call you at any moment in time. In multi-core CPUs (are there any others?)
your code can execute multiple times in any given instant. There will be dragons
here.</p>

<p>Except for a few sissy Java EE App servers, this is the standard way of working for Java.
Get over it, accept it! You must consider the concurrency issues of your code. For this,
there are some excellent books out there that explain the issues. The most famous
one being Brian Goetz’ book <a href="https://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601">Java Concurrency in Practice</a>, the bullet train book.</p>

<p>This App note attempts to handle some of the important issues when you write OSGi
applications, especially with DS. However, being an app note it of course remains
on the surface of this complex topic.</p>

<p>The App note has a complementary workspace with all the different components
that are used to discuss the issue. You can find this workspace on <a href="https://github.com/osgi/osgi.enroute.examples.concurrency">Github</a>.
If you want to understand the many patterns better then load this workspace
in Bndtools and run the tests. (As a note, all components use service=… only
to make them easier to test.)</p>

<p>This App Note was sponsored by <a href="http://www.sma.de/">SMA</a>.</p>

<h2 id="time-is-more-relative-than-you-think">Time is More Relative than You Think</h2>

<p>Today’s multi-core CPUs are amazing pieces of technology that use every trick in the
book to get the awesome performance we see today. To achieve this power CPU designers
could not maintain some invariants that software developers were accustomed to.</p>

<p>For a software developer it is horror to think that writing a variable does not mean
that all executing code can see the new content. Unfortunately, this is
life on modern multi-core CPUs. The <a href="https://github.com/osgi/osgi.enroute.examples.concurrency/tree/master/osgi.enroute.examples.concurrency.sync/src/osgi/enroute/examples/concurrency/sync">following code</a> looks like it should stop but
it might not on a multi-core machine.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="nd">@Component</span><span class="o">(</span><span class="n">service</span><span class="o">=</span><span class="n">StopLoopWithNormalVariable</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kd">class</span> <span class="nc">StopLoopWithNormalVariable</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>

		<span class="kt">boolean</span> <span class="n">stop</span><span class="o">;</span>

		<span class="nd">@Activate</span>
		<span class="kt">void</span> <span class="nf">activate</span><span class="o">()</span> <span class="o">{</span>
			<span class="n">start</span><span class="o">();</span>
		<span class="o">}</span>

		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
			<span class="k">while</span> <span class="o">(!</span><span class="n">stop</span><span class="o">)</span>
				<span class="o">;</span>
		<span class="o">}</span>

		<span class="nd">@Deactivate</span>
		<span class="kt">void</span> <span class="nf">deactivate</span><span class="o">()</span> <span class="o">{</span>
			<span class="n">stop</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>
</code></pre>
</div>

<p>The reason is that the background loop could run on its own core. This core has
its own cached copy of main memory because main memory is too slow to access on every usage.
So when the <code class="highlighter-rouge">deactivate</code> method writes a <code class="highlighter-rouge">true</code> in the <code class="highlighter-rouge">stop</code> variable, the background
thread remains oblivious of this since it uses its cached copy.</p>

<p>Sometimes the code actually works as one would expect. Strangely enough, if you
run this code in the debugger with a breakpoint in the loop then it will work as expected.
This is not a <a href="https://en.wikipedia.org/wiki/Heisenbug">Heisenbug</a> but is caused because the debugger inadvertently causes the
caches to be synchronized with main memory. As the debugger demonstrates, this is
a non-deterministic effect and any good developer should hate this kind of indeterministic
behavior.</p>

<p>That is why Java has a <em>memory model</em>. This does not make it easy but at least it makes
it predictable.</p>

<p>The following picture shows some key aspects of this memory model:</p>

<p><img src="img/concurrency/conc-barriers.png" alt="Write/Read Barriers" /></p>

<p>The model allows each core to execute independently from each other core using its own
cached main memory. Though the cache can hide updates from other cores haphazardly, two constructs
force the situation to become deterministic.</p>

<p>The first construct is the <code class="highlighter-rouge">volatile</code> keyword. When a volatile variable is written the VM <em>must</em> ensure that, directly after the instruction, the cache is finished writing all prior updates to main
memory. When a volatile variable is read the value must be the same as in main memory.
These are called the <em>write barrier</em> and the <em>read barrier</em>.</p>

<p>What happens between read and write barriers is left to the implementation. Compilers
and cores are free to reorder reads and writes for any reason they see fit. (Usually
to make your code run faster.) However, if you can <em>prove</em> a variable is written
before a volatile write then that variable <em>must</em> be visible for anybody that has done
a volatile read. For example,</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">;</span>
	<span class="kd">volatile</span> <span class="kt">int</span> <span class="n">v</span><span class="o">;</span>

	<span class="kt">void</span> <span class="nf">foo</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">a</span><span class="o">;</span>
		<span class="n">v</span> <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="n">c</span><span class="o">;</span>
	<span class="o">}</span>
</code></pre>
</div>

<p>Another thread may see the assignment of <code class="highlighter-rouge">c</code> before the assignment of <code class="highlighter-rouge">a</code> (or not at all) but
after it reads <code class="highlighter-rouge">v</code>, the other variables must have their proper values assigned.</p>

<p>To write proper code it is therefore paramount to understand the <em>happens before</em> relation.
Fortunately, the OSGi specifications make it very clear what the order of
certain operations is. Once the order is defined, you have a proper happens before
relation and you’re guaranteed to see anything that was written before you were
called.</p>

<p>As a note, a happens before relation is always between two threads although it is
transitive between threads. In the following picture the colors of the thread
bars show that though thread B makes lots of modifications, these modifications
are only defined to be visible by thread A after thread B had a write barrier
and thread A a read barrier. That is, there’s been established a firm happens before
relation.</p>

<p><img src="img/concurrency/conc-before-after.png" alt="Write/Read Barriers" /></p>

<p>A bit of warning here. The tricky part is that most code that calls out to
other libraries tends to go through lots of read/write barriers and works
as intended. However, there is no guarantee until you can prove that there is
a proper happens before relation. That is, your code works fine in the debugger
but fails in runtime. That is, the fact that something works for you is not an
indication that you’ve done your work properly.</p>

<h2 id="atomicity">Atomicity</h2>

<p>Volatile variables are not atomic. For example, the following code can fail:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="kd">volatile</span> <span class="kt">int</span> <span class="n">v</span><span class="o">;</span>

	<span class="kt">void</span> <span class="nf">foo</span><span class="o">()</span> <span class="o">{</span> <span class="n">v</span><span class="o">++;</span> <span class="o">}</span> <span class="c1">// BAD!!!!</span>
</code></pre>
</div>

<p>In this example it is possible to miss an increment because thread A can read the
variable in a register, increment it, and then store it. However, when we’re unlucky
another thread reads the same value, increments it and stores it as well. This
will lose one of the updates. The more cores you have, the higher the chance this
will happen but it can actually also happen on a single core machine.</p>

<p>How do we protect against this?</p>

<p>First, there are special types in <code class="highlighter-rouge">java.util.concurrent</code> that provide high level
constructs that prevent many of the problems that plague the initial <code class="highlighter-rouge">synchronized</code>.
For this example, the Atomic Integer would be the most practical solution.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="kd">final</span> <span class="n">AtomicInteger</span>	<span class="n">v</span><span class="o">=</span> <span class="k">new</span> <span class="n">AtomicInteger</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

	<span class="kt">void</span> <span class="nf">foo</span><span class="o">()</span> <span class="o">{</span> <span class="n">v</span><span class="o">.</span><span class="na">incrementAndGet</span><span class="o">();</span> <span class="o">}</span>
</code></pre>
</div>

<p>However, it helps understanding the problems these high level constructs solve by
taking a look at the <code class="highlighter-rouge">synchronized</code> keyword. Some problems are easier to solve with the
<code class="highlighter-rouge">synchronized</code> keyword.</p>

<p>For this problem, Java knows the construct of a <em>synchronized</em> block. A synchronized block takes a
<em>lock</em> object. When the synchronized block is entered it attempts to get a lock
on that object for the current thread. Only one thread can get this lock at any moment
in time.</p>

<p>Once the thread has the lock, it will perform a read barrier, ensuring that the cache and the
main memory are synchronized. This brings us in the wonderful position that
we are the only thread that owns the locked object and has a correct view of main memory.
This of course does not mean other threads see the same main memory. Other threads
should defer working with these variables except when inside a synchronized block that
protects them.</p>

<p>We can now read, make a decision on the value, and
write without having to worry that other threads interfere if they lock on the same
object while writing those variables.</p>

<p>At the end of the synchronized block the VM will create a write barrier, waiting
until all writes so far are flushed to main memory. Only then will it release the lock.</p>

<p>Therefore the following code would properly count the number of calls to <code class="highlighter-rouge">foo</code>.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="kt">int</span> <span class="n">v</span><span class="o">;</span>
	<span class="kd">final</span> <span class="n">Object</span> <span class="n">vLock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">();</span> <span class="c1">// protectes v</span>

	<span class="kt">void</span> <span class="nf">foo</span><span class="o">()</span> <span class="o">{</span>
		<span class="kd">synchronized</span><span class="o">(</span><span class="n">vLock</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">v</span><span class="o">++;</span>
		<span class="o">}</span>
	<span class="o">}</span>
</code></pre>
</div>

<p>Since the synchronized block does a read barrier just after it gets the lock
and a write barrier just before it returns the lock we’re guaranteed the following:</p>

<ul>
  <li>Only one thread updates <code class="highlighter-rouge">v</code></li>
  <li>Any thread in the block can see the changes of another thread that was in that synchronized block before</li>
</ul>

<h3 id="deadlocks">Deadlocks</h3>

<p>Synchronized blocks are slow due to the lock and crossing two barriers. They also have
limitations.</p>

<p>A synchronized block must be short and should not call out to <em>foreign</em> code. Foreign code is code that is not under
the same control as the author of the synchronized block. The danger is that
a synchronized block can cause a <em>deadlock</em> that way. Thread A is in a synchronized
block and causes Thread B to wait for that synchronized block. Since A now waits for B
and B waits for A they are in a deadly embrace. The chance for deadlocks is increased
massively with nested synchronizations.</p>

<p>If you cannot avoid blocking then make sure that you always acquire locks in
a consistent order. If one order is always followed for multiple locks then
a deadlock cannot occur.</p>

<h3 id="special-lock-object">Special Lock Object</h3>

<p>For this reasons synchronized blocks should only be used for the update of <em>owned</em>
data structures and not call out to foreign code. They should also not use any
object that is available outside their private scope. That is, never use a
service object to synchronize on since anybody can do that. Either use a private
object that plays a role in the scenario or create a specific object for it
with <code class="highlighter-rouge">new Object</code>. If you have a number of variables that are protected by the
same lock then it might be a good idea to put all of them in a private class:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="kd">static</span> <span class="kd">private</span> <span class="kd">class</span> <span class="nc">Atomic</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">a</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">b</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">final</span> <span class="n">Atomic</span> <span class="n">together</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Atomic</span><span class="o">();</span>

	<span class="kt">void</span> <span class="nf">foo</span><span class="o">()</span> <span class="o">{</span>
		<span class="kd">synchronized</span><span class="o">(</span><span class="n">together</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">together</span><span class="o">.</span><span class="na">a</span><span class="o">++;</span>
			<span class="n">together</span><span class="o">.</span><span class="na">b</span><span class="o">--;</span>
		<span class="o">}</span>
	<span class="o">}</span>
</code></pre>
</div>

<p>Last but not least, never use the <code class="highlighter-rouge">wait()</code> and <code class="highlighter-rouge">notify()</code> methods associated with
synchronized blocks. Those use cases have effectively been replaced with the
many utility types in <code class="highlighter-rouge">java.util.concurrent</code>. For example, in the increment example, there
is a perfectly valid replacement with the <code class="highlighter-rouge">AtomicInteger</code>
class that has an increment method. However, in certain cases when the decision is
more complicated there is still use for the synchronized blocks.</p>

<p>For example, the following code serializes the execution of a Runnable without
requiring support for background threads. If no Runnable’s are in progress it will
execute on the current thread otherwise it queues the Runnable to be executed after
the current queued Runnable’s are finished.</p>

<p>Clearly, this requires atomic decisions. First we must decide if there are one or
more Runnable’s in progress when we arrive. Second, we need to decide if there
are Runnable’s queued once we’ve ran a Runnable.</p>

<p><a href="https://github.com/osgi/osgi.enroute.examples.concurrency/tree/master/osgi.enroute.examples.concurrency.sync/src/osgi/enroute/examples/concurrency/serialize">For example</a>:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="nd">@Component</span><span class="o">(</span><span class="n">service</span><span class="o">=</span><span class="n">Serializer</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Serializer</span> <span class="o">{</span>

		<span class="n">List</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span> <span class="n">serialized</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
		<span class="n">Object</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">();</span>

		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">serialize</span><span class="o">(</span><span class="n">Runnable</span> <span class="n">runnable</span><span class="o">)</span> <span class="o">{</span>

			<span class="kd">synchronized</span><span class="o">(</span><span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span> <span class="n">serialized</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">)</span> <span class="o">{</span>
					<span class="n">serialized</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">runnable</span><span class="o">);</span>
					<span class="k">return</span><span class="o">;</span>
				<span class="o">}</span>
				<span class="n">serialized</span><span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
			<span class="o">}</span>

			<span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>

				<span class="k">try</span> <span class="o">{</span>
					<span class="n">runnable</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
				<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
				<span class="o">}</span>

				<span class="kd">synchronized</span><span class="o">(</span><span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
					<span class="k">if</span> <span class="o">(</span> <span class="n">serialized</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">)</span> <span class="o">{</span>
						<span class="n">serialized</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
						<span class="k">return</span><span class="o">;</span>
					<span class="o">}</span>
					<span class="n">runnable</span> <span class="o">=</span> <span class="n">serialized</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>
</code></pre>
</div>

<p>(If the serialize method is very heavily used then this algorithm may block progress on a single thread since
it must keep serving the queue. But you saw that of course?)</p>

<h2 id="atomic-objects">Atomic Objects</h2>

<p>Since synchronized blocks are deadlock prone many algorithms have been developed to
solve concurrent problems with <em>lock free</em> structures. In general these structures
replace locks with a retry model. Modern processors have <em>compare and set</em> instructions
that can atomically set a memory location while returning the previous value. Though
this must pass the memory barriers it is more efficient in comparison with
a lock.</p>

<h2 id="atomically-closing">Atomically Closing</h2>

<p>There frequently is a potential race condition between the close operation
caused by an unbind method and the deactivate method in DS. In such cases it is
a good idea to create a <code class="highlighter-rouge">close</code> method that can be called multiple times. The
standard pattern is to use an Atomic Boolean.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="kd">final</span> <span class="n">AtomicBoolean</span> <span class="n">open</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicBoolean</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span> <span class="n">open</span><span class="o">.</span><span class="na">getAndSet</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span> <span class="o">==</span> <span class="kc">false</span> <span class="o">)</span>
			<span class="k">return</span><span class="o">;</span>

		<span class="c1">// free to do the close operations</span>
		<span class="c1">// without worrying about this race condition</span>
		<span class="c1">// and we're not holding a lock!</span>
	<span class="o">}</span>
</code></pre>
</div>

<p>Such a method guarantees that only the ‘first’ close operation will execute
the close. The close code will then run safely outside any lock.</p>

<h2 id="guarantees-from-ds">Guarantees from DS</h2>

<p>In many aspects DS is a dependency injection (DI) engine similar to Spring, Guice, or
CDI. However, in contrast with these DI engines DS components have a life cycle.
This adds the dimension of <em>time</em> to the component, something that is utterly lacking in
any other DI engine. DS components are dynamic.</p>

<p>Though this extra dimension provides tremendous power it clearly comes with the
burden that things do not only get initialized, it is also possible that things go
away.</p>

<p>DS goes out of its way to hide that complexity. The way DS achieves this is through
very strong guarantees. DS absorbs a tremendous amount of complexity so that you
don’t have to worry about it. However, many a developer writes their code defensively
and overly locks/synchronizes parts. So let’s see what we can rely on.</p>

<h3 id="ordering">Ordering</h3>

<p>DS provides a very strict ordering. This ordering implies that there is a very clear
happens before relationship between the different phases. There is no gain using volatile
variables or other synchronization constructs between these phases because this is
already been done by DS. That is, if you set an instance variable in the constructor
then there is a full guarantee that this variable is visible in the bind
or activate methods even if these methods, as is allowed, were called on different threads.</p>

<p>The following is the guaranteed ordering that a DS component can observe:</p>

<ol>
  <li>Constructor – DS will always create a new object, it will <strong>never</strong> reuse an existing object.</li>
  <li>Bind – The bind methods or field injections are called in alphabetical order when using annotations.
(Though dynamic methods or field injections can of course be called at any time.)</li>
  <li>Activate – Only if all static reference methods and field injections are called is the activate method called. If this method does
not throw an exception, it is guaranteed that the deactivate will be called. If
an exception is thrown the following phases are not executed.</li>
  <li>Active – During the active phase the following methods can be called in any order from
any thread and in parallel:
    <ul>
      <li>Any methods of the registered services</li>
      <li>A modified methods that dynamically takes the modified configuration properties</li>
      <li>Any of the updated reference methods if defined</li>
    </ul>
  </li>
  <li>Deactivate – Clean up</li>
  <li>Unbinds – And unbind methods are called</li>
  <li>Release of object – DS will release the object so that no longer any references are held</li>
  <li>Finalize – Java garbage collects the object</li>
</ol>

<p>Lazy services are registered before their constructor is called. The initialization of the
DS component will take place when the service is used for the first time. However, this
should not be observable by the component itself.</p>

<h2 id="static-references">Static References</h2>

<p>The default and simplest model of DS is to use <code class="highlighter-rouge">static</code> references. If a component only has
static references then it never sees any of the OSGi dynamics. This means that
with the given ordering there is no need to use volatile or other
synchronization constructs for static references. (Of course the service methods are
still called from different threads.) Field injection is the most
simple way but bind and the optional unbind methods do not require any synchronization constructs.</p>

<p>Sadly, many developers that start using dynamic references making the grave error of premature optimization. Yes,
you can wring more performance out of a computer making these components dynamic but
it is rarely worth the added complexity. Only go to dynamics with things like the
whiteboard and/or when you measure a significant cost for being static. In almost
all cases the static model where the component is destroyed and then recreated works
extremely well … really.</p>

<p>Anyway, remember the rules about optimization:</p>

<ul>
  <li>Do not optimize!</li>
  <li>Only for the experts, do not optimize yet!</li>
</ul>

<h2 id="optional-references">Optional References</h2>

<p>Sometimes a component can deliver its functionality even when a reference is
absent. This is then an <em>optional</em> reference. By far the simplest method to
handle this is to make the reference optional by specifying the cardinality:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="nd">@Component</span><span class="o">(</span><span class="n">service</span><span class="o">=</span><span class="n">ReluctantOptionalReference</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReluctantOptionalReference</span> <span class="o">{</span>

		<span class="nd">@Reference</span><span class="o">(</span><span class="n">cardinality</span><span class="o">=</span><span class="n">ReferenceCardinality</span><span class="o">.</span><span class="na">OPTIONAL</span><span class="o">)</span>
		<span class="n">Foo</span> <span class="n">reluctantOptionalReference</span><span class="o">;</span>

	<span class="o">}</span>
</code></pre>
</div>

<p>However, this is a <em>static</em> reference. This implies that the component is started
regardless of the presence of Foo. If Foo happens to be there then it is injected
otherwise the field remains <code class="highlighter-rouge">null</code>. This model is called <em>reluctant</em>.</p>

<p>Unfortunately, this means we miss the Foo service when it is registered a few
nanoseconds later. Since the static model has so many advantages there is an option
to reconstruct the component when this reference finds a candidate. This
is the <em>greedy</em> mode:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="nd">@Component</span><span class="o">(</span><span class="n">service</span><span class="o">=</span><span class="n">GreedyOptionalReference</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GreedyOptionalReference</span> <span class="o">{</span>

		<span class="nd">@Reference</span><span class="o">(</span>
			<span class="n">cardinality</span><span class="o">=</span><span class="n">ReferenceCardinality</span><span class="o">.</span><span class="na">OPTIONAL</span><span class="o">,</span>
			<span class="n">policyOption</span><span class="o">=</span><span class="n">ReferencePolicyOption</span><span class="o">.</span><span class="na">GREEDY</span><span class="o">)</span>
		<span class="n">Foo</span> <span class="n">greedyOptionalReference</span><span class="o">;</span>
	<span class="o">}</span>
</code></pre>
</div>

<p>DS will now reconstruct the component when there is a <em>better</em> candidate for
<code class="highlighter-rouge">foo</code>. Clearly any candidate will beat no candidate but what means better in the
case that we already have <code class="highlighter-rouge">foo</code>?</p>

<p>When multiple candidates are available DS will sort them by ranking. Services
with a higher <em>ranking</em> are deemed <em>better</em>. Service ranking is indicated by a
property called <code class="highlighter-rouge">service.ranking</code>. It is an integer, higher is better.</p>

<p>One of the advantages of the static model is that in your activate method all
the way to your deactivate method your visible world won’t change.</p>

<p>The previous examples were still static because none of the references changed
between the <code class="highlighter-rouge">activate</code> and <code class="highlighter-rouge">deactivate</code> phase. The greedy policy option achieved
its replacement by reconstructing the component. This is acceptable in most
cases but sometimes the component does not want to die for the sake of an
optional reference. In that case we can handle the situation <em>dynamically</em>.</p>

<p>By far the easiest solution is to mark the field as <em>volatile</em>. <strong>A volatile
field will automatically get marked as <code class="highlighter-rouge">policy=DYNAMIC</code></strong>.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="nd">@Component</span><span class="o">(</span><span class="n">service</span><span class="o">=</span><span class="n">DynamicOptionalReference</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DynamicOptionalReference</span> <span class="o">{</span>

		<span class="nd">@Reference</span><span class="o">(</span><span class="n">cardinality</span><span class="o">=</span><span class="n">ReferenceCardinality</span><span class="o">.</span><span class="na">OPTIONAL</span><span class="o">)</span>
		<span class="kd">volatile</span> <span class="n">Foo</span> <span class="n">dynamicOptionalReference</span><span class="o">;</span>
	<span class="o">}</span>
</code></pre>
</div>

<p>This is simple but there is an obvious price. The following bad code shows
a common (but horrible) pattern that people use to use <code class="highlighter-rouge">foo</code>:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="k">if</span> <span class="o">(</span> <span class="n">foo</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">)</span> <span class="c1">// BAD!</span>
		<span class="n">foo</span><span class="o">.</span><span class="na">bar</span><span class="o">();</span>
</code></pre>
</div>

<p>This innocuous looking code is actually a Null Pointer Exception in the waiting.
A better way is to do:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="n">Foo</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">foo</span><span class="o">;</span>
	<span class="k">if</span> <span class="o">(</span> <span class="n">foo</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">)</span>
		<span class="n">foo</span><span class="o">.</span><span class="na">bar</span><span class="o">();</span>
</code></pre>
</div>

<p>By using a local variable we guarantee that the check (is <code class="highlighter-rouge">foo null</code>?) is using the
same object as the one we will call <code class="highlighter-rouge">bar()</code> on. This is a very cheap form of
synchronization.</p>

<h2 id="but-what-if-the-service-disappears">But What If The Service Disappears?</h2>

<p>A common question that now appears is: ‘What if the service goes away?’. You
could be in the process of calling a service when it becomes unregistered. Sometimes
this will cause the service to throw exceptions sometimes you get a Service Exception.</p>

<p>In general it is one of those cases where ‘shit happens’. In a concurrent environment
like Java it is possible to end up in a sad place. Your code should always be prepared
to accept exceptions when you call other services. This does not mean you should catch
them, on the contrary. It is much better to forward the exceptions to the caller
so that they do not unnecessarily get wrapped up in wrapping exceptions and lose the
original context.</p>

<p>In almost all cases there is a top level function that initiated your request. It
is this function that has the responsibility to make sure the overall system
keeps working regardless of failures. This kind of robustness code is extremely
difficult to get right and should <strong>never</strong> be mixed with application code.</p>

<p>However, any locks you hold in a method should be released and resources should be closed. Any code
you call can cause exceptions. Relying on other code and not handling their exceptions
(even if they are not declared) is living a very optimistic, naive, and likely short
professional life.</p>

<h2 id="tracking-multiple-services">Tracking Multiple Services</h2>

<p>If you use a whiteboard pattern or other listener like model then in general
you want to use dynamics. The reason is that you have <em>multiple</em> references
and building and destroying the component at every change in the set of services
we’re interested in (the <em>tracked</em> services) becomes expensive.</p>

<p>By far the easiest method is to use field injection of a list of services.
If you make this field <code class="highlighter-rouge">volatile</code> then DS will inject a new list whenever the
set of tracked services changes.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="nd">@Component</span><span class="o">(</span><span class="n">service</span><span class="o">=</span><span class="n">SimpleList</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleList</span> <span class="o">{</span>

		<span class="nd">@Reference</span>
		<span class="kd">volatile</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span>		<span class="n">dynamicFoos</span><span class="o">;</span>
	<span class="o">}</span>
</code></pre>
</div>

<p>However, there are many scenarios where the component must interact with the bind
and unbind of the references. The most common way is then to create a bind
and unbind method.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="nd">@Component</span><span class="o">(</span><span class="n">service</span> <span class="o">=</span> <span class="n">DynamicBindUnbind</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DynamicBindUnbind</span> <span class="o">{</span>

		<span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">foos</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CopyOnWriteArrayList</span><span class="o">&lt;&gt;();</span>

		<span class="nd">@Reference</span><span class="o">(</span>
			<span class="n">cardinality</span> <span class="o">=</span> <span class="n">ReferenceCardinality</span><span class="o">.</span><span class="na">MULTIPLE</span><span class="o">,</span>
			<span class="n">policy</span> <span class="o">=</span> <span class="n">ReferencePolicy</span><span class="o">.</span><span class="na">DYNAMIC</span><span class="o">)</span>
		<span class="kt">void</span> <span class="nf">addFoo</span><span class="o">(</span><span class="n">Foo</span> <span class="n">foo</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">foos</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">foo</span><span class="o">);</span>
		<span class="o">}</span>

		<span class="kt">void</span> <span class="nf">removeFoo</span><span class="o">(</span><span class="n">Foo</span> <span class="n">foo</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">foos</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">foo</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
</code></pre>
</div>

<p>In this example we use a <code class="highlighter-rouge">CopyOnWriteArrayList</code>. This is a so called <em>non-locking</em>
object. Though it is perfectly safe to use in a concurrent environment it will not
use locks and any iteration over that list is guaranteed not to fail. Many list
types in Java will fail with a Concurrent Modification Exception if you add/remove
a value while another thread iterates. A <code class="highlighter-rouge">CopyOnWriteArrayList</code> won’t. It has a simple
trick for this. Instead of adding a new element to the list, it replaces the
internal storage array with a new array. Iterations iterate over this array. Though
this means the iteration can visit stale objects, the length of the array and its
content will never change. Each iteration will be bound to a single generation.</p>

<h3 id="indexing">Indexing</h3>

<p>Clearly, the previous example is identical to the <code class="highlighter-rouge">volatile List</code> example where DS
did the trick of <code class="highlighter-rouge">CopyOnWriteArrayList</code> replacing the list whenever there was a
change. Usually the bind/unbind methods are used when it is necessary to
do something with the referenced service. A common case is indexing the service
in a map with a service property. This looks as follows:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="nd">@Component</span><span class="o">(</span><span class="n">service</span><span class="o">=</span><span class="n">PlainIndexedServices</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PlainIndexedServices</span> <span class="o">{</span>

		<span class="kd">final</span> <span class="n">ConcurrentMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Foo</span><span class="o">&gt;</span> <span class="n">plainServices</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;&gt;();</span>

		<span class="nd">@Reference</span><span class="o">(</span>
			<span class="n">cardinality</span><span class="o">=</span><span class="n">ReferenceCardinality</span><span class="o">.</span><span class="na">MULTIPLE</span><span class="o">,</span>
			<span class="n">policy</span><span class="o">=</span><span class="n">ReferencePolicy</span><span class="o">.</span><span class="na">DYNAMIC</span><span class="o">)</span>
		<span class="kt">void</span> <span class="nf">addFoo</span><span class="o">(</span><span class="n">Foo</span> <span class="n">foo</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">props</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">String</span> <span class="n">key</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="n">props</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"id"</span><span class="o">);</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
				<span class="k">return</span><span class="o">;</span>

			<span class="n">plainServices</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">foo</span><span class="o">);</span>
		<span class="o">}</span>

		<span class="kt">void</span> <span class="nf">removeFoo</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">props</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">String</span> <span class="n">key</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="n">props</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"id"</span><span class="o">);</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
				<span class="k">return</span><span class="o">;</span>
			<span class="n">plainServices</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
</code></pre>
</div>

<p>This example shows a number of non-obvious issues. First the <code class="highlighter-rouge">ConcurrentHashMap</code> is
a thread safe non-locking map. We can safely use it and we’re guaranteed that it won’t
lock. (It achieves this by retrying its operations so this does not mean it
returns immediately.)</p>

<p>Second, it does not handle the situation when the “id” property is not used in
a unique way. If multiple different services use the same id then this code could
get confused.</p>

<h3 id="wrapping">Wrapping</h3>

<p>In numerous cases when we use indexed services we need to track a number of
variables based on each service. That is, when a new service enters the system
we need to do some work that creates data we do not want to loose until we
no longer track the service.</p>

<p>In an object oriented environment the easiest way is to create a wrapper around
the service. This wrapper can hold the per-service data and we can use its methods
to handle the behavior. A simplistic example:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="kd">class</span> <span class="nc">Wrap</span> <span class="o">{</span>
		<span class="kd">final</span> <span class="n">Foo</span> <span class="n">foo</span><span class="o">;</span>
		<span class="kt">boolean</span> <span class="n">closed</span><span class="o">;</span>

		<span class="kd">public</span> <span class="nf">Wrap</span><span class="o">(</span><span class="n">Foo</span> <span class="n">foo</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">this</span><span class="o">.</span><span class="na">foo</span> <span class="o">=</span> <span class="n">foo</span><span class="o">;</span>
		<span class="o">}</span>

		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="o">{</span>
			<span class="n">closed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>
</code></pre>
</div>

<p>This raises a life cycle issue. In the previous example we ignored any
services that went away or had the same id. This is acceptable because we had no cleaning
up to do after the service disappeared. With a wrapper there is no such
luxury since we need to close the wrapper. We therefore need to detect duplicates
and we need to detect and handle them in a thread-safe way.</p>

<p>The Concurrent Map API specifies that both <code class="highlighter-rouge">put</code> and <code class="highlighter-rouge">remove</code> return the object
that was at that moment associated with the given key. The concept of <em>previous</em> is
an atomic concept. That is, if a key is removed twice on different threads only one
will return a previous value and the other will receive <code class="highlighter-rouge">null</code>.</p>

<p>In both the <code class="highlighter-rouge">add</code> and <code class="highlighter-rouge">remove</code> bind methods we therefore need to close the
previous wrapper, if any.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="nd">@Component</span><span class="o">(</span><span class="n">service</span><span class="o">=</span><span class="n">WrappedIndexedServices</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WrappedIndexedServices</span> <span class="o">{</span>

		<span class="kd">final</span> <span class="n">ConcurrentMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Wrap</span><span class="o">&gt;</span> <span class="n">wrappedServices</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;&gt;();</span>

		<span class="nd">@Reference</span><span class="o">(</span>
			<span class="n">cardinality</span><span class="o">=</span><span class="n">ReferenceCardinality</span><span class="o">.</span><span class="na">MULTIPLE</span><span class="o">,</span>
			<span class="n">policy</span><span class="o">=</span><span class="n">ReferencePolicy</span><span class="o">.</span><span class="na">DYNAMIC</span><span class="o">)</span>
		<span class="kt">void</span> <span class="nf">addFoo</span><span class="o">(</span><span class="n">Foo</span> <span class="n">foo</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">props</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">String</span> <span class="n">key</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="n">props</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"id"</span><span class="o">);</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
				<span class="k">return</span><span class="o">;</span>

			<span class="n">Wrap</span> <span class="n">previous</span> <span class="o">=</span> <span class="n">wrappedServices</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="k">new</span> <span class="n">Wrap</span><span class="o">(</span><span class="n">foo</span><span class="o">));</span>
			<span class="k">if</span> <span class="o">(</span> <span class="n">previous</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">previous</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
			<span class="o">}</span>
		<span class="o">}</span>

		<span class="kt">void</span> <span class="nf">removeFoo</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">props</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">String</span> <span class="n">key</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="n">props</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"id"</span><span class="o">);</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
				<span class="k">return</span><span class="o">;</span>

			<span class="n">Wrap</span> <span class="n">previous</span> <span class="o">=</span> <span class="n">wrappedServices</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
			<span class="k">if</span> <span class="o">(</span> <span class="n">previous</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">previous</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>
</code></pre>
</div>

<h3 id="multiple-services-per-key">Multiple Services per Key</h3>

<p>In the previous example there was the implicit assumption that there was a
unique key per service. However, in some use cases a key can map to multiple
services. This complicates our problem a bit. Let’s first design a holder for
our services</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="kd">class</span> <span class="nc">Holder</span> <span class="o">{</span>
		<span class="kd">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">foos</span> <span class="o">=</span>  <span class="n">ConcurrentHashMap</span><span class="o">.</span><span class="na">newKeySet</span><span class="o">();</span>

		<span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span> <span class="n">Foo</span> <span class="n">foo</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">return</span> <span class="n">foos</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">foo</span><span class="o">);</span>
		<span class="o">}</span>

		<span class="kt">boolean</span> <span class="nf">remove</span><span class="o">(</span> <span class="n">Foo</span> <span class="n">foo</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">return</span> <span class="n">foos</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">foo</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
</code></pre>
</div>

<p>Since Java does not have a ConcurrentSet we create one by using the key set
from the Concurrent Hash Map. A bit hackish but the only way in Java.</p>

<p>Since the bind/unbind methods are called concurrent we must ensure that we atomically
process the addition of the first and the removal of the last. In this code we
use the <code class="highlighter-rouge">compute</code> methods on Concurrent Map.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="nd">@Component</span><span class="o">(</span><span class="n">service</span><span class="o">=</span><span class="n">HolderIndexedMultipleServices</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HolderIndexedMultipleServices</span> <span class="o">{</span>

		<span class="kd">final</span> <span class="n">ConcurrentMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Holder</span><span class="o">&gt;</span> <span class="n">multis</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;&gt;();</span>

		<span class="nd">@Reference</span><span class="o">(</span>
			<span class="n">cardinality</span><span class="o">=</span><span class="n">ReferenceCardinality</span><span class="o">.</span><span class="na">MULTIPLE</span><span class="o">,</span>
			<span class="n">policy</span><span class="o">=</span><span class="n">ReferencePolicy</span><span class="o">.</span><span class="na">DYNAMIC</span><span class="o">)</span>
		<span class="kt">void</span> <span class="nf">addFoo</span><span class="o">(</span><span class="n">Foo</span> <span class="n">foo</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">props</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">String</span> <span class="n">key</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="n">props</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"id"</span><span class="o">);</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
				<span class="k">return</span><span class="o">;</span>

			<span class="n">multis</span><span class="o">.</span><span class="na">compute</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span><span class="n">v</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span> <span class="n">v</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
					<span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Holder</span><span class="o">();</span>
				<span class="n">v</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">foo</span><span class="o">);</span>
				<span class="k">return</span> <span class="n">v</span><span class="o">;</span>
			<span class="o">});</span>
		<span class="o">}</span>

		<span class="kt">void</span> <span class="nf">removeFoo</span><span class="o">(</span><span class="n">Foo</span> <span class="n">foo</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">props</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">String</span> <span class="n">key</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span> <span class="n">props</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"id"</span><span class="o">);</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
				<span class="k">return</span><span class="o">;</span>

			<span class="n">multis</span><span class="o">.</span><span class="na">computeIfPresent</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span><span class="n">v</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
				<span class="n">v</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">foo</span><span class="o">);</span>
				<span class="k">return</span> <span class="n">v</span><span class="o">.</span><span class="na">foos</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">v</span><span class="o">;</span>
			<span class="o">});</span>
		<span class="o">}</span>
	<span class="o">}</span>
</code></pre>
</div>

<p>The <code class="highlighter-rouge">compute</code> methods map an old value to the next value. However, no lock is held,
which implies that the mapping method can be called multiple times. This requires
therefore that our mapping function is <em>idempotent</em>.</p>

<p>That is, we must be able to call it multiple times without creating side effects. For this reason we use a
<code class="highlighter-rouge">Set</code> instead of a <code class="highlighter-rouge">List</code> to ensure there are no duplicates. Adding to a list could cause multiple same Foo
services to be the list.</p>

<p>In the <code class="highlighter-rouge">removeFoo</code> method we use the <code class="highlighter-rouge">computeIfPresent</code> method which only calls our
mapping function if the key already exists. Again, also this function can be called multiple
times and must also be idempotent.</p>

<!--
1. Should there be a note about equality here since these map/set examples rely on it?

2. Should there be a note about service ordering in these, or is that out of scope or left as an excersize for the reader to explore.
-->

<p>You can find the code for these examples <a href="https://github.com/osgi/osgi.enroute.examples.concurrency/tree/master/osgi.enroute.examples.concurrency.sync/src/osgi/enroute/examples/concurrency/dynamic">here</a>;</p>

<h2 id="cycles">Cycles</h2>

<p>A very nasty problem exists when there are cycles in your service references. If component Bottom
has a static reference to component Top and Top has references to all Bottom’s then you have
a cycle. This is not an uncommon case but will not work in a simple way with DS
even though the specification explicitly allows it for dynamic references. The problem is
that many services are lazy.</p>

<p>DS implementations run into problems when the Top component is being injected
with the dynamic Bottom services. If Bottom is defined as <em>lazy</em> then the construction
of Bottom fails.</p>

<p>A lazy service is registered as a service but not yet created. It is created on demand. However, the demand comes from
the exact object that needs to be injected so it is not yet ready for injection. You will therefore get an
error like ‘Circular reference detected, getService returning null’.</p>

<p>The best solution to this problem is to make the Bottom service <code class="highlighter-rouge">immediate</code>. Since
the Bottom service has a mandatory reference on the Top service it will not register
a service before the Top component is registered as a service. Once the Top service is registered,
the Bottom service(s) are satisfied and can then register. This registration will then
cause their injection in the Top component since Top has dynamic references to
Bottom.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="nd">@Component</span><span class="o">(</span><span class="n">service</span><span class="o">=</span><span class="n">Top</span><span class="o">.</span><span class="na">class</span><span class="o">,</span><span class="n">immediate</span><span class="o">=</span><span class="kc">false</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Top</span> <span class="o">{</span>

		<span class="nd">@Reference</span>
		<span class="kd">volatile</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Bottom</span><span class="o">&gt;</span>		<span class="n">circularReferenceToBottoms</span><span class="o">;</span>

	<span class="o">}</span>

	<span class="nd">@Component</span><span class="o">(</span><span class="n">service</span><span class="o">=</span><span class="n">Bottom</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">immediate</span><span class="o">=</span><span class="kc">true</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Bottom</span> <span class="o">{</span>

		<span class="nd">@Reference</span>
		<span class="n">Top</span>			<span class="n">circularReferenceToTop</span><span class="o">;</span>

	<span class="o">}</span>
</code></pre>
</div>

<p>See for the code <a href="https://github.com/osgi/osgi.enroute.examples.concurrency/tree/master/osgi.enroute.examples.concurrency.sync/src/osgi/enroute/examples/concurrency/cycle">here</a>.</p>

<h2 id="background-threads">Background Threads</h2>

<p>One of the easiest ways to prevent concurrency problems is to execute all code
on a single thread. This is called <em>thread confinement</em>. Any work that gets queued on this thread will then not
require any synchronization. This pattern is used in many cases to actually increase
performance because the only synchronization required is the queuing of the
the work operations. All work can then be executed without locks and barriers inside
the thread.</p>

<p>However, these loops must be extremely well protected against exceptions. Once
the background thread loop exits it is game over. The following code shows
a background thread that executes the work in a single thread.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="nd">@Component</span>
	<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Background</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="kd">implements</span> <span class="n">Work</span> <span class="o">{</span>

		<span class="kd">final</span> <span class="n">BlockingQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span>	<span class="n">queue</span>	<span class="o">=</span> <span class="k">new</span> <span class="n">LinkedBlockingQueue</span><span class="o">&lt;&gt;();</span>
		<span class="kt">int</span>								<span class="n">counter</span><span class="o">;</span>

		<span class="kd">public</span> <span class="nf">Background</span><span class="o">()</span> <span class="o">{</span>
			<span class="kd">super</span><span class="o">(</span><span class="s">"Background"</span><span class="o">);</span>
		<span class="o">}</span>

		<span class="nd">@Activate</span>
		<span class="kt">void</span> <span class="nf">activate</span><span class="o">()</span> <span class="o">{</span>
			<span class="n">start</span><span class="o">();</span>
		<span class="o">}</span>

		<span class="nd">@Deactivate</span>
		<span class="kt">void</span> <span class="nf">deactivate</span><span class="o">()</span> <span class="o">{</span>
			<span class="n">interrupt</span><span class="o">();</span>
		<span class="o">}</span>

		<span class="nd">@Override</span>
		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">work</span><span class="o">()</span> <span class="o">{</span>
			<span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
				<span class="n">counter</span><span class="o">++;</span>
			<span class="o">});</span>
		<span class="o">}</span>

		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
			<span class="k">while</span> <span class="o">(!</span><span class="n">isInterrupted</span><span class="o">())</span>
				<span class="k">try</span> <span class="o">{</span>
					<span class="n">Runnable</span> <span class="n">take</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">take</span><span class="o">();</span>
					<span class="k">try</span> <span class="o">{</span>
						<span class="n">take</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
					<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
						<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
					<span class="o">}</span>
				<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">interrupt</span><span class="o">();</span>
					<span class="k">return</span><span class="o">;</span>
				<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
				<span class="o">}</span> <span class="k">finally</span><span class="o">{</span>
					<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Exiting background"</span><span class="o">);</span>
				<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>
</code></pre>
</div>

<p>You can find the code <a href="https://github.com/osgi/osgi.enroute.examples.concurrency/tree/master/osgi.enroute.examples.concurrency.sync/src/osgi/enroute/examples/concurrency/queue">here</a>.</p>

<h2 id="io-server">IO Server</h2>

<p>A related problem is when IO needs be processed synchronously, for example a
TCP/IP socket server. The inner loop is even more complicated than the inner
loop of the simple queuing example because there are more failure scenarios.</p>

<ul>
  <li>The interrupt we used in that previous example does not work for the synchronous
Java IO calls. To stop these loops, it will be necessary to close the
server socket.</li>
  <li>We need to ensure that errors are not overloading the system. It will be necessary
to delay for some time between errors.</li>
  <li>All connections that are opened must be closed when the component is deactivated.</li>
</ul>

<p>This is surprisingly complex as the following code testifies:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="nd">@Component</span><span class="o">(</span><span class="n">immediate</span><span class="o">=</span><span class="kc">true</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BackgroundIO</span> <span class="kd">extends</span> <span class="n">Thread</span> <span class="o">{</span>

		<span class="n">ServerSocket</span>	<span class="n">serverSocket</span><span class="o">;</span>

		<span class="nd">@Reference</span>
		<span class="n">Executor</span>		<span class="n">executor</span><span class="o">;</span>

		<span class="kd">public</span> <span class="nf">BackgroundIO</span><span class="o">()</span> <span class="o">{</span>
			<span class="kd">super</span><span class="o">(</span><span class="s">"BackgroundIO"</span><span class="o">);</span>
		<span class="o">}</span>

		<span class="nd">@Activate</span>
		<span class="kt">void</span> <span class="nf">startBackgroundThread</span><span class="o">()</span> <span class="o">{</span>
			<span class="n">start</span><span class="o">();</span>
		<span class="o">}</span>

		<span class="nd">@Deactivate</span>
		<span class="kt">void</span> <span class="nf">stopBackgroundThread</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
			<span class="n">interrupt</span><span class="o">();</span>
			<span class="n">bestEffortClose</span><span class="o">(</span><span class="n">serverSocket</span><span class="o">);</span>
		<span class="o">}</span>

		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>

			<span class="n">List</span><span class="o">&lt;</span><span class="n">Socket</span><span class="o">&gt;</span> <span class="n">openConnections</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CopyOnWriteArrayList</span><span class="o">&lt;&gt;();</span>

			<span class="k">try</span> <span class="o">{</span>
				<span class="k">while</span> <span class="o">(!</span><span class="n">isInterrupted</span><span class="o">())</span>
					<span class="k">try</span> <span class="o">{</span>
						<span class="n">serverSocket</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ServerSocket</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
						<span class="k">while</span> <span class="o">(!</span><span class="n">isInterrupted</span><span class="o">())</span> <span class="o">{</span>
							<span class="n">Socket</span> <span class="n">connection</span> <span class="o">=</span> <span class="n">serverSocket</span><span class="o">.</span><span class="na">accept</span><span class="o">();</span>
							<span class="k">try</span> <span class="o">{</span>
								<span class="n">openConnections</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">connection</span><span class="o">);</span>
								<span class="n">processConnection</span><span class="o">(</span><span class="n">connection</span><span class="o">,</span><span class="n">openConnections</span><span class="o">);</span>
							<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
								<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
							<span class="o">}</span>
						<span class="o">}</span>
					<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>

						<span class="c1">// No report of exceptions</span>
						<span class="c1">// when we're interrupted</span>

						<span class="k">if</span> <span class="o">(</span><span class="n">isInterrupted</span><span class="o">())</span>
							<span class="k">return</span><span class="o">;</span>

						<span class="n">t</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>

						<span class="k">try</span> <span class="o">{</span>
							<span class="c1">// Prevent overload (e.g. bind exception</span>
							<span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
						<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
							<span class="n">interrupt</span><span class="o">();</span>
							<span class="k">return</span><span class="o">;</span>
						<span class="o">}</span>
					<span class="o">}</span>
			<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">t</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
				<span class="k">throw</span> <span class="n">t</span><span class="o">;</span>
			<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
				<span class="n">bestEffortClose</span><span class="o">(</span><span class="n">serverSocket</span><span class="o">);</span>
				<span class="n">openConnections</span><span class="o">.</span><span class="na">forEach</span><span class="o">(</span> <span class="k">this</span><span class="o">::</span><span class="n">bestEffortClose</span> <span class="o">);</span>
			<span class="o">}</span>
		<span class="o">}</span>

		<span class="kd">private</span> <span class="kt">void</span> <span class="nf">bestEffortClose</span><span class="o">(</span><span class="n">AutoCloseable</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">try</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span> <span class="n">s</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
					<span class="k">return</span><span class="o">;</span>
				<span class="n">s</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
			<span class="o">}</span> <span class="k">catch</span><span class="o">(</span> <span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
				<span class="c1">//ignore</span>
			<span class="o">}</span>
		<span class="o">}</span>

		<span class="kd">private</span> <span class="kt">void</span> <span class="nf">processConnection</span><span class="o">(</span><span class="n">Socket</span> <span class="n">connection</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Socket</span><span class="o">&gt;</span> <span class="n">openConnections</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">executor</span><span class="o">.</span><span class="na">execute</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
				<span class="k">try</span> <span class="o">{</span>
					<span class="k">while</span><span class="o">(</span><span class="n">connection</span><span class="o">.</span><span class="na">isConnected</span><span class="o">())</span> <span class="o">{</span>
						<span class="c1">// do work</span>
					<span class="o">}</span>
				<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
					<span class="n">openConnections</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">connection</span><span class="o">);</span>
					<span class="n">bestEffortClose</span><span class="o">(</span><span class="n">connection</span><span class="o">);</span>
				<span class="o">}</span>
			<span class="o">});</span>
		<span class="o">}</span>
	<span class="o">}</span>
</code></pre>
</div>

<h2 id="event-loops">Event Loops</h2>

<p>In many scenarios it is necessary to send events to other services; this often
happens in whiteboard scenarios. Just like the background loops, event loops
must be written very defensively to not kill the main task of the service. This often
is an argument to use the OSGi Event Admin to handle the events since the Event
Admin will handle many scenarios where an Event Handler acts badly.</p>

<p>However, in certain cases it is necessary to handle these events in your code.
The following is a template for a well protected event loop with blacklisting.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="nd">@Component</span><span class="o">(</span><span class="n">service</span> <span class="o">=</span> <span class="n">EventLoop</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EventLoop</span> <span class="o">{</span>

		<span class="nd">@Reference</span>
		<span class="kd">volatile</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">EventHandler</span><span class="o">&gt;</span>		<span class="n">handlers</span><span class="o">;</span>

		<span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">EventHandler</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span>	<span class="n">blacklist</span>	<span class="o">=</span> <span class="n">Collections</span>
				<span class="o">.</span><span class="na">synchronizedMap</span><span class="o">(</span><span class="k">new</span> <span class="n">WeakHashMap</span><span class="o">&lt;&gt;());</span>

		<span class="nd">@Reference</span>
		<span class="n">Executor</span>						<span class="n">executor</span><span class="o">;</span>

		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">dispatch</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">handlers</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
				<span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="k">this</span><span class="o">::</span><span class="n">timeout</span><span class="o">)</span>
				<span class="o">.</span><span class="na">forEach</span><span class="o">((</span><span class="n">handler</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">dispatchInBackground</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">handler</span><span class="o">));</span>
		<span class="o">}</span>

		<span class="kd">private</span> <span class="kt">void</span> <span class="nf">dispatchInBackground</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">EventHandler</span> <span class="n">handler</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">executor</span><span class="o">.</span><span class="na">execute</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
				<span class="k">try</span> <span class="o">{</span>
					<span class="n">handler</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
				<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">blacklist</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">handler</span><span class="o">,</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">+</span> <span class="mi">5000</span><span class="o">);</span>
					<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
				<span class="o">}</span>
			<span class="o">});</span>
		<span class="o">}</span>

		<span class="kt">boolean</span> <span class="nf">timeout</span><span class="o">(</span><span class="n">EventHandler</span> <span class="n">handler</span><span class="o">)</span> <span class="o">{</span>
			<span class="kt">long</span> <span class="n">currentTimeMillis</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
			<span class="n">Long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">blacklist</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">handler</span><span class="o">);</span>

			<span class="k">if</span> <span class="o">(</span><span class="n">timeout</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>

				<span class="k">if</span> <span class="o">(</span><span class="n">timeout</span> <span class="o">&gt;</span> <span class="n">currentTimeMillis</span><span class="o">)</span>
					<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

				<span class="n">blacklist</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">handler</span><span class="o">);</span>
			<span class="o">}</span>
			<span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>
</code></pre>
</div>

<p>You can find this code <a href="https://github.com/osgi/osgi.enroute.examples.concurrency/tree/master/osgi.enroute.examples.concurrency.sync/src/osgi/enroute/examples/concurrency/events">here</a>.</p>

<h2 id="asynchronous-apis">Asynchronous APIs</h2>

<p>Though threads are in general not as expensive as developers think, they do consume
resources. In many systems significant performance gains can be achieved when
processing is done asynchronously instead of calling a blocking API.</p>

<p>In these scenarios the OSGi Promise is a friend because it provides a simple but
very powerful model to chain asynchronous calls while not forgetting exception
management. The basic model of a Promise is:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="n">Promise</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="nf">getBar</span><span class="o">()</span> <span class="o">{</span>
		<span class="n">Promise</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span>	<span class="n">p</span> <span class="o">=</span> <span class="n">startFoo</span><span class="o">();</span>
		<span class="k">return</span> <span class="n">p</span>
			<span class="o">.</span><span class="na">then</span><span class="o">(</span> <span class="k">this</span><span class="o">::</span><span class="n">step1</span> <span class="o">)</span>
			<span class="o">.</span><span class="na">then</span><span class="o">(</span> <span class="k">this</span><span class="o">::</span><span class="n">step2</span> <span class="o">)</span>
			<span class="o">.</span><span class="na">then</span><span class="o">(</span> <span class="k">this</span><span class="o">::</span><span class="n">step3</span> <span class="o">)</span>
			<span class="o">.</span><span class="na">then</span><span class="o">(</span> <span class="k">this</span><span class="o">::</span><span class="n">step4</span> <span class="o">)</span>
			<span class="o">.</span><span class="na">then</span><span class="o">(</span> <span class="k">this</span><span class="o">::</span><span class="n">step5</span><span class="o">,</span> <span class="k">this</span><span class="o">::</span><span class="n">failure</span> <span class="o">);</span>
	<span class="o">}</span>
</code></pre>
</div>

<p>In the real world this code will execute completely independent of its invocation.
Each step will be executed when the previous step is <em>resolved</em>. The best part of
it all is that when any of the steps fail, the final promise failure method
is invoked. This makes it relatively easy to sequence a number of steps
without blocking a thread.</p>

<p>A Promise is created with a Deferred. The template for using a Promise looks like:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="nd">@Component</span><span class="o">(</span><span class="n">service</span> <span class="o">=</span> <span class="n">Factorial</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Factorial</span> <span class="o">{</span>

		<span class="nd">@Reference</span>
		<span class="n">Executor</span> <span class="n">executor</span><span class="o">;</span>

		<span class="kd">public</span> <span class="n">Promise</span><span class="o">&lt;</span><span class="n">BigInteger</span><span class="o">&gt;</span> <span class="nf">fac</span><span class="o">(</span><span class="kt">long</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">Deferred</span><span class="o">&lt;</span><span class="n">BigInteger</span><span class="o">&gt;</span> <span class="n">deferred</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Deferred</span><span class="o">&lt;&gt;();</span>
			<span class="n">executor</span><span class="o">.</span><span class="na">execute</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
				<span class="k">try</span> <span class="o">{</span>
					<span class="n">BigInteger</span> <span class="n">result</span> <span class="o">=</span> <span class="n">BigInteger</span><span class="o">.</span><span class="na">ONE</span><span class="o">;</span>
					<span class="k">for</span> <span class="o">(</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span> <span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
						<span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">multiply</span><span class="o">(</span> <span class="n">BigInteger</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
					<span class="o">}</span>
					<span class="n">deferred</span><span class="o">.</span><span class="na">resolve</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
				<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
					<span class="n">deferred</span><span class="o">.</span><span class="na">fail</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
				<span class="o">}</span>
			<span class="o">});</span>
			<span class="k">return</span> <span class="n">deferred</span><span class="o">.</span><span class="na">getPromise</span><span class="o">();</span>
		<span class="o">}</span>

	<span class="o">}</span>
</code></pre>
</div>

<p>You can find this code <a href="https://github.com/osgi/osgi.enroute.examples.concurrency/tree/master/osgi.enroute.examples.concurrency.sync/src/osgi/enroute/examples/concurrency/promise">here</a>.</p>

<h2 id="activation-and-initialization-with-promises">Activation and Initialization with Promises</h2>

<p>The activate method (a method marked with the @Activate annotation) is called
before the service is registered. This method should not stay away too long.
What to do when there is some lengthy initialization? A common pattern
is to start the initialization on a background thread but then block in all
methods that require the initialization to have finished. These are the
service methods and also the deactivate method.</p>

<p>An ideal object for this is the OSGi <em>Promise</em>. It can defer an operation
to the future. In the following example we show how to use a promise to:</p>

<ul>
  <li>start the initialization in a background thread</li>
  <li>block until the initialization is finished when called on a working method of the service</li>
  <li>defer the deactivate method until initialization is done. This can potentially mean that
the actual close method is called on another thread, much later than the deactivate method.</li>
</ul>

<p>The following code implements this.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="nd">@Component</span>
	<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Initialize</span> <span class="kd">implements</span> <span class="n">Work</span> <span class="o">{</span>
		<span class="n">Promise</span><span class="o">&lt;</span><span class="n">Delegate</span><span class="o">&gt;</span>	<span class="n">promise</span><span class="o">;</span>
		<span class="kd">volatile</span> <span class="kt">boolean</span>	<span class="n">closed</span><span class="o">;</span>

		<span class="nd">@Reference</span>
		<span class="n">Executor</span>			<span class="n">executor</span><span class="o">;</span>

		<span class="nd">@Activate</span>
		<span class="kt">void</span> <span class="nf">activate</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
			<span class="n">Deferred</span><span class="o">&lt;</span><span class="n">Delegate</span><span class="o">&gt;</span> <span class="n">deferred</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Deferred</span><span class="o">&lt;&gt;();</span>
			<span class="n">executor</span><span class="o">.</span><span class="na">execute</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
				<span class="k">try</span> <span class="o">{</span>
					<span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2000</span><span class="o">);</span> <span class="c1">// long running init</span>
					<span class="n">deferred</span><span class="o">.</span><span class="na">resolve</span><span class="o">(</span><span class="k">new</span> <span class="n">Delegate</span><span class="o">());</span>
				<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">deferred</span><span class="o">.</span><span class="na">fail</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
				<span class="o">}</span>
			<span class="o">});</span>
			<span class="n">promise</span> <span class="o">=</span> <span class="n">deferred</span><span class="o">.</span><span class="na">getPromise</span><span class="o">();</span>
		<span class="o">}</span>

		<span class="nd">@Override</span>
		<span class="kd">public</span> <span class="kt">void</span> <span class="nf">work</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
			<span class="n">promise</span><span class="o">.</span><span class="na">getValue</span><span class="o">().</span><span class="na">work</span><span class="o">();</span>
		<span class="o">}</span>

		<span class="nd">@Deactivate</span>
		<span class="kt">void</span> <span class="nf">deactivate</span><span class="o">()</span> <span class="o">{</span>
			<span class="n">promise</span><span class="o">.</span><span class="na">onResolve</span><span class="o">(</span><span class="k">this</span><span class="o">::</span><span class="n">close</span><span class="o">);</span>
		<span class="o">}</span>

		<span class="kt">void</span> <span class="nf">close</span><span class="o">()</span> <span class="o">{</span>
			<span class="n">closed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>
</code></pre>
</div>

<p>You can find this code <a href="https://github.com/osgi/osgi.enroute.examples.concurrency/tree/master/osgi.enroute.examples.concurrency.sync/src/osgi/enroute/examples/concurrency/init">here</a>.</p>

<h2 id="modifying-configuration-properties">Modifying Configuration Properties</h2>

<p>If the configuration of a component changes then DS can dynamically update the
component if it defines a <em>modified</em> method. This method must be marked with the
@Modified annotation. The following is an example.</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="nd">@Component</span><span class="o">(</span><span class="n">service</span><span class="o">=</span><span class="n">DynamicModifiedConfiguration</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">configurationPolicy</span><span class="o">=</span><span class="n">ConfigurationPolicy</span><span class="o">.</span><span class="na">REQUIRE</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DynamicModifiedConfiguration</span> <span class="o">{</span>

		<span class="kt">int</span>		<span class="n">config</span><span class="o">;</span>

		<span class="nd">@interface</span> <span class="n">Config</span> <span class="o">{</span>
			<span class="kt">int</span> <span class="nf">config</span><span class="o">()</span> <span class="k">default</span> <span class="mi">1</span><span class="o">;</span>
		<span class="o">}</span>

		<span class="nd">@Activate</span>
		<span class="kt">void</span> <span class="nf">activate</span><span class="o">(</span><span class="n">Config</span> <span class="n">config</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">this</span><span class="o">.</span><span class="na">config</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="na">config</span><span class="o">();</span>
		<span class="o">}</span>

		<span class="nd">@Modified</span>
		<span class="kt">void</span> <span class="nf">modified</span><span class="o">(</span><span class="n">Config</span> <span class="n">config</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">this</span><span class="o">.</span><span class="na">config</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="na">config</span><span class="o">();</span>
		<span class="o">}</span>
	<span class="o">}</span>
</code></pre>
</div>

<p>You can find this code <a href="https://github.com/osgi/osgi.enroute.examples.concurrency/tree/master/osgi.enroute.examples.concurrency.sync/src/osgi/enroute/examples/concurrency/modified">here</a>.</p>

<h2 id="updating-the-service-properties-of-a-reference">Updating the Service Properties of a Reference</h2>

<p>If the service properties of a service change while a component has a reference then the
component must be reactivated unless it has defined an <em>updated</em> method. The updated
method is added by giving it the name of the reference prefixed with <code class="highlighter-rouge">updated</code>. The
following code shows this:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>	<span class="nd">@Component</span><span class="o">(</span><span class="n">service</span><span class="o">=</span><span class="n">DynamicUpdatedReferenceProperties</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DynamicUpdatedReferenceProperties</span> <span class="o">{</span>

		<span class="kt">int</span> <span class="n">foo</span><span class="o">;</span>

		<span class="nd">@Reference</span>
		<span class="kt">void</span> <span class="nf">setFoo</span><span class="o">(</span> <span class="n">Foo</span> <span class="n">foo</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">this</span><span class="o">.</span><span class="na">foo</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="s">"property"</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
		<span class="o">}</span>

		<span class="kt">void</span> <span class="nf">updatedFoo</span><span class="o">(</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">this</span><span class="o">.</span><span class="na">foo</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="s">"property"</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
</code></pre>
</div>

<p>You can find this code <a href="https://github.com/osgi/osgi.enroute.examples.concurrency/tree/master/osgi.enroute.examples.concurrency.sync/src/osgi/enroute/examples/concurrency/modified_ref">here</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Concurrency and its associated areas are hard. Software is hard. We hope that this
app note helped you see a number of error scenarios and provide you with some
patterns to solve these problems.</p>

<p>If you know more patterns and/or error scenarios then do not hesitate to provide
a Pull Request on this repository. This is one way of saying thank you.</p>

